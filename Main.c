#include "STC15F2K60S2.h"

/**********************
引脚别名定义
***********************/
sbit LED=P2^3;
sbit P3_5 = P3^5;								//红外线发送引脚
sbit P3_7 = P3^7;								//串口1发送引脚
/**********************
全局变量定义
***********************/
unsigned char send_time=0;//用于降低发送频率
unsigned char send_flag=0;

unsigned int temp_time=0;
unsigned long int sumt=0;	
unsigned int date_temp=0;
unsigned char temp=0;
unsigned char tempdisplay=0;

unsigned char duanxuan[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x40,0x00,0x09,0x73}; 
int code tempdata[]={
	239,197,175,160,150,142,135,129,124,120,116,113,109,107,104,101,99,97,95,93,91,90,88,86,85,84,82,81,80,78,77,76,75,
	74,73,72,71,70,69,68,67,67,66,65,64,63,63,62,61,61,60,59,58,58,57,57,56,55,55,54,54,53,52,52,51,51,50,50,49,49,48,
	48,47,47,46,46,45,45,44,44,43,43,42,42,41,41,41,40,40,39,39,38,38,38,37,37,36,36,36,35,35,34,34,34,33,33,32,32,32,
	31,31,31,30,30,29,29,29,28,28,28,27,27,27,26,26,26,25,25,24,24,24,23,23,23,22,22,22,21,21,21,20,20,20,19,19,19,18,
	18,18,17,17,16,16,16,15,15,15,14,14,14,13,13,13,12,12,12,11,11,11,10,10,9,9,9,8,8,8,7,7,7,6,6,5,5,5,4,4,3,3,3,2,2,
	1,1,1,0,0,-1,-1,-1,-2,-2,-3,-3,-4,-4,-5,-5,-6,-6,-7,-7,-8,-8,-9,-9,-10,-10,-11,-11,-12,-13,-13,-14,-14,-15,-16,-16,
	-17,-18,-19,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-32,-33,-35,-36,-38,-40,-43,-46,-50,-55,-63,361};

/***********************************
*初始化串口1的相关设置，设定串口的波特率等
***********************************/
void Uart1_Init()
{
	PCON &= 0x7F;		//波特率不倍速，SMOD=0
	SCON = 0x50;		//串口1使用工作方式1，REN=1(允许串行接收)
	AUXR &= 0xFE;		//串口1选择定时器T1作为波特率发生器，S1ST2=0
	AUXR1 = 0x40;		//串口1在P3.6接收，在P3.7发送
	PS = 1;					//设置串口中断为最高优先级
	PADC=0;
}

/***********************************
* 定时器相关设置
***********************************/
void Timer_Init(){
	
	//定时器T1,用于产生波特率
	AUXR |= 0x40;		//定时器T1为1T模式，速度是传统8051的12倍，不分频。
	TMOD &= 0x0F;		//清除T1模式位
	TMOD |= 0x20;		//设置T1模式位，使用8位自动重装模式
	TL1 = 0x70;			//设置初值
	TH1 = 0x70;			//设置T1重装值
	TR1 = 1;				//T1运行控制位置1，允许T1计数
	

	//使用定时器T0,定时为1ms
 	AUXR |= 0x80;		//定时器T0为1T模式，的速度是传统8051的12倍，不分频。
	TMOD &= 0xF0;		//清除T0模式位
	TMOD |= 0x02;		//设置T0模式位，使用8位自动重装模式
	TL0 = 0x70;			//设置初值
	TH0 = 0x70;			//设T0重装值
	TF0 = 0;				//T0溢出标志位清零
	TR0 = 1;				//T0运行控制位置1，允许T0计数
	
	//定时器T2为12T模式，用于定时发送温度数据
	T2H=0;
	T2L=0;
	AUXR |= 0x10;		//定时器2开始计时
}

/*******************
* 系统初始化
********************/
void Init(){
	
	P0M1=0x00;
  P0M0=0xff;

	P2M1=0x00;
	P2M0=0x08;
	LED=0;

	IE2 = 0X04;		//打开定时器2中断
	IE = 0xB2; //打开总中断EA=1，打开串口1中断ES=1，打开定时器0中断ET0=1，打开AD中断
}

/*******************
* 初始化温度ADC
********************/
void InitADC_temp()
{
	P1ASF=0xfc;
	ADC_RES=0;
	ADC_RESL=0;
	ADC_CONTR=0XeB;
	CLK_DIV=0X20;	
}

/********************************
 * 定时器0中断的操作
********************************/
void Time0() interrupt 1
{
	if(P3_7==0)			//P3_5根据P3_7的信号产生脉冲
	{
		P3_5 = ~P3_5;
	}
	else						//如果P3.7=1则P3.5输出0
		P3_5 = 0;
}

/********************************
 * 串口1中断的操作。发送完毕TI自动置1，产生中断
********************************/
void URAT1() interrupt 4
{
	if(RI)							//判断是否接收中断
		RI = 0;						//接收中断请求标志位清0
	
	if(TI)							//判断是否发送中断
	{
		TI = 0;						//发送中断请求标志位清0
		if(send_flag==1)				//判断是否第一次发送
		{
			send_flag = 2;				//第二次发送数据
			SBUF = tempdisplay;	
		}
		if(send_flag == 2)
			send_flag = 0;
	}
}

/*******************
* AD中断
********************/
void ADC() interrupt 5 using 1
{
	temp_time++;	
	if(temp_time>2000)
	{
		temp=(sumt+temp_time/2)/temp_time;			//四舍五入
		sumt=0;
		temp_time=0;
	}
	//对应温度的数据处理
	date_temp=(ADC_RES*256+ADC_RESL)/4;//由10位AD值转换为8位AD值
	sumt+=date_temp;						//求t次AD值的和
	ADC_CONTR&=~0X10;	
	//转换完成后，ADC_START赋1
	ADC_CONTR|=0X08;	
}

/********************************
 * 定时器2中断的操作
********************************/
void Timer2() interrupt 12{
	if(send_flag==0&&send_time==20)						//判断是否可以发送
	{
		send_time = 0;
		send_flag = 1;						//第一次先发送一个标志,降低接受的错误数据的可能性
		SBUF = 0xca;				//标志为0xca，发送完后在串口中断中再发送数据
	}
	send_time++;
}


/*******************
* 延时函数
********************/
void Delay(int n)
{
	int y;
	while(n--)
	{
		y=60;
		while(y--);
	}
}

/*******************
* 数码管显示
********************/
void Display() 
{
	tempdisplay=tempdata[temp];
	P2=0x06;
	P0=duanxuan[tempdisplay%100/10];
	Delay(10);
	P2=0x07;
	P0=duanxuan[tempdisplay%10];
	Delay(10);
	P0=0x00;
}

void main()
{
	Uart1_Init();
	Timer_Init();
	Init();
	P0=0x00;
	while(1){
		InitADC_temp();
		Display();
	}
} 