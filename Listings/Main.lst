C51 COMPILER V9.54   MAIN                                                                  09/12/2015 23:42:16 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\Main
                    -.lst) TABS(2)

line level    source

   1          #include "STC15F2K60S2.h"
   2          
   3          /**********************
   4          引脚别名定义
   5          ***********************/
   6          sbit LED=P2^3;
   7          sbit P3_5 = P3^5;               //红外线发送引脚
   8          sbit P3_7 = P3^7;               //串口1发送引脚
   9          /**********************
  10          全局变量定义
  11          ***********************/
  12          unsigned char send_time=0;//用于降低发送频率
  13          unsigned char send_flag=0;
  14          
  15          unsigned int temp_time=0;
  16          unsigned long int sumt=0; 
  17          unsigned int date_temp=0;
  18          unsigned char temp=0;
  19          unsigned char tempdisplay=0;
  20          
  21          unsigned char duanxuan[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,
             -0x40,0x00,0x09,0x73}; 
  22          int code tempdata[]={
  23            239,197,175,160,150,142,135,129,124,120,116,113,109,107,104,101,99,97,95,93,91,90,88,86,85,84,82,81,80,78
             -,77,76,75,
  24            74,73,72,71,70,69,68,67,67,66,65,64,63,63,62,61,61,60,59,58,58,57,57,56,55,55,54,54,53,52,52,51,51,50,50,
             -49,49,48,
  25            48,47,47,46,46,45,45,44,44,43,43,42,42,41,41,41,40,40,39,39,38,38,38,37,37,36,36,36,35,35,34,34,34,33,33,
             -32,32,32,
  26            31,31,31,30,30,29,29,29,28,28,28,27,27,27,26,26,26,25,25,24,24,24,23,23,23,22,22,22,21,21,21,20,20,20,19,
             -19,19,18,
  27            18,18,17,17,16,16,16,15,15,15,14,14,14,13,13,13,12,12,12,11,11,11,10,10,9,9,9,8,8,8,7,7,7,6,6,5,5,5,4,4,3
             -,3,3,2,2,
  28            1,1,1,0,0,-1,-1,-1,-2,-2,-3,-3,-4,-4,-5,-5,-6,-6,-7,-7,-8,-8,-9,-9,-10,-10,-11,-11,-12,-13,-13,-14,-14,-1
             -5,-16,-16,
  29            -17,-18,-19,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-32,-33,-35,-36,-38,-40,-43,-46,-50,-55,-63,3
             -61};
  30          
  31          /***********************************
  32          *初始化串口1的相关设置，设定串口的波特率等
  33          ***********************************/
  34          void Uart1_Init()
  35          {
  36   1        PCON &= 0x7F;   //波特率不倍速，SMOD=0
  37   1        SCON = 0x50;    //串口1使用工作方式1，REN=1(允许串行接收)
  38   1        AUXR &= 0xFE;   //串口1选择定时器T1作为波特率发生器，S1ST2=0
  39   1        AUXR1 = 0x40;   //串口1在P3.6接收，在P3.7发送
  40   1        PS = 1;         //设置串口中断为最高优先级
  41   1        PADC=0;
  42   1      }
  43          
  44          /***********************************
  45          * 定时器相关设置
  46          ***********************************/
C51 COMPILER V9.54   MAIN                                                                  09/12/2015 23:42:16 PAGE 2   

  47          void Timer_Init(){
  48   1        
  49   1        //定时器T1,用于产生波特率
  50   1        AUXR |= 0x40;   //定时器T1为1T模式，速度是传统8051的12倍，不分频。
  51   1        TMOD &= 0x0F;   //清除T1模式位
  52   1        TMOD |= 0x20;   //设置T1模式位，使用8位自动重装模式
  53   1        TL1 = 0x70;     //设置初值
  54   1        TH1 = 0x70;     //设置T1重装值
  55   1        TR1 = 1;        //T1运行控制位置1，允许T1计数
  56   1        
  57   1      
  58   1        //使用定时器T0,定时为1ms
  59   1        AUXR |= 0x80;   //定时器T0为1T模式，的速度是传统8051的12倍，不分频。
  60   1        TMOD &= 0xF0;   //清除T0模式位
  61   1        TMOD |= 0x02;   //设置T0模式位，使用8位自动重装模式
  62   1        TL0 = 0x70;     //设置初值
  63   1        TH0 = 0x70;     //设T0重装值
  64   1        TF0 = 0;        //T0溢出标志位清零
  65   1        TR0 = 1;        //T0运行控制位置1，允许T0计数
  66   1        
  67   1        //定时器T2为12T模式，用于定时发送温度数据
  68   1        T2H=0;
  69   1        T2L=0;
  70   1        AUXR |= 0x10;   //定时器2开始计时
  71   1      }
  72          
  73          /*******************
  74          * 系统初始化
  75          ********************/
  76          void Init(){
  77   1        
  78   1        P0M1=0x00;
  79   1        P0M0=0xff;
  80   1      
  81   1        P2M1=0x00;
  82   1        P2M0=0x08;
  83   1        LED=0;
  84   1      
  85   1        IE2 = 0X04;   //打开定时器2中断
  86   1        IE = 0xB2; //打开总中断EA=1，打开串口1中断ES=1，打开定时器0中断ET0=1，打开AD中断
  87   1      }
  88          
  89          /*******************
  90          * 初始化温度ADC
  91          ********************/
  92          void InitADC_temp()
  93          {
  94   1        P1ASF=0xfc;
  95   1        ADC_RES=0;
  96   1        ADC_RESL=0;
  97   1        ADC_CONTR=0XeB;
  98   1        CLK_DIV=0X20; 
  99   1      }
 100          
 101          /********************************
 102           * 定时器0中断的操作
 103          ********************************/
 104          void Time0() interrupt 1
 105          {
 106   1        if(P3_7==0)     //P3_5根据P3_7的信号产生脉冲
 107   1        {
 108   2          P3_5 = ~P3_5;
C51 COMPILER V9.54   MAIN                                                                  09/12/2015 23:42:16 PAGE 3   

 109   2        }
 110   1        else            //如果P3.7=1则P3.5输出0
 111   1          P3_5 = 0;
 112   1      }
 113          
 114          /********************************
 115           * 串口1中断的操作。发送完毕TI自动置1，产生中断
 116          ********************************/
 117          void URAT1() interrupt 4
 118          {
 119   1        if(RI)              //判断是否接收中断
 120   1          RI = 0;           //接收中断请求标志位清0
 121   1        
 122   1        if(TI)              //判断是否发送中断
 123   1        {
 124   2          TI = 0;           //发送中断请求标志位清0
 125   2          if(send_flag==1)        //判断是否第一次发送
 126   2          {
 127   3            send_flag = 2;        //第二次发送数据
 128   3            SBUF = tempdisplay; 
 129   3          }
 130   2          if(send_flag == 2)
 131   2            send_flag = 0;
 132   2        }
 133   1      }
 134          
 135          /*******************
 136          * AD中断
 137          ********************/
 138          void ADC() interrupt 5 using 1
 139          {
 140   1        temp_time++;  
 141   1        if(temp_time>2000)
 142   1        {
 143   2          temp=(sumt+temp_time/2)/temp_time;      //四舍五入
 144   2          sumt=0;
 145   2          temp_time=0;
 146   2        }
 147   1        //对应温度的数据处理
 148   1        date_temp=(ADC_RES*256+ADC_RESL)/4;//由10位AD值转换为8位AD值
 149   1        sumt+=date_temp;            //求t次AD值的和
 150   1        ADC_CONTR&=~0X10; 
 151   1        //转换完成后，ADC_START赋1
 152   1        ADC_CONTR|=0X08;  
 153   1      }
 154          
 155          /********************************
 156           * 定时器2中断的操作
 157          ********************************/
 158          void Timer2() interrupt 12{
 159   1        if(send_flag==0&&send_time==20)           //判断是否可以发送
 160   1        {
 161   2          send_time = 0;
 162   2          send_flag = 1;            //第一次先发送一个标志,降低接受的错误数据的可能性
 163   2          SBUF = 0xca;        //标志为0xca，发送完后在串口中断中再发送数据
 164   2        }
 165   1        send_time++;
 166   1      }
 167          
 168          
 169          /*******************
 170          * 延时函数
C51 COMPILER V9.54   MAIN                                                                  09/12/2015 23:42:16 PAGE 4   

 171          ********************/
 172          void Delay(int n)
 173          {
 174   1        int y;
 175   1        while(n--)
 176   1        {
 177   2          y=60;
 178   2          while(y--);
 179   2        }
 180   1      }
 181          
 182          /*******************
 183          * 数码管显示
 184          ********************/
 185          void Display() 
 186          {
 187   1        tempdisplay=tempdata[temp];
 188   1        P2=0x06;
 189   1        P0=duanxuan[tempdisplay%100/10];
 190   1        Delay(10);
 191   1        P2=0x07;
 192   1        P0=duanxuan[tempdisplay%10];
 193   1        Delay(10);
 194   1        P0=0x00;
 195   1      }
 196          
 197          void main()
 198          {
 199   1        Uart1_Init();
 200   1        Timer_Init();
 201   1        Init();
 202   1        P0=0x00;
 203   1        while(1){
 204   2          InitADC_temp();
 205   2          Display();
 206   2        }
 207   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    455    ----
   CONSTANT SIZE    =    510    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
